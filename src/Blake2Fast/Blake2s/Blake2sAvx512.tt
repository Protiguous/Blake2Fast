<#@ template language="C#" #>
<#@ output extension=".cs" encoding="utf-8" #>
// Copyright Â© Clinton Ingram and Contributors.  Licensed under the MIT License.

//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

#if HWINTRINSICS && NET8_0_OR_GREATER
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Blake2Fast.Implementation;

#if BLAKE2_PUBLIC
public
#else
internal
#endif
unsafe partial struct Blake2sHashState
{
	// SIMD algorithm described in https://eprint.iacr.org/2012/275.pdf
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	private static void mixAvx512(uint* sh, uint* m)
	{
		// This nonsense breaks CSE of these reads, tricking JIT into allocating low regsiters to the row vars.
		nuint zero = Sse2.CompareGreaterThan(Vector128<int>.Zero, Vector128<int>.Zero).AsUInt32().ToScalar();
		uint* piv = (uint*)Unsafe.AsPointer(ref MemoryMarshal.GetReference(ivle)) + zero;
		var row3 = Sse2.LoadVector128(piv);
		var row4 = Sse2.LoadVector128(piv + Vector128<uint>.Count);

		// Again breaking CSE, otherwise JIT wastes good registers caching these reads that aren't used again until the end.
		var row1 = Sse2.LoadVector128(sh + zero);
		var row2 = Sse2.LoadVector128(sh + zero + Vector128<uint>.Count);

		row4 = Sse2.Xor(row4, Sse2.LoadVector128(sh + Vector128<uint>.Count * 2)); // t[] and f[]

		var m0 = Sse2.LoadVector128(m);
		var m1 = Sse2.LoadVector128(m + Vector128<uint>.Count);
		var m2 = Sse2.LoadVector128(m + Vector128<uint>.Count * 2);
		var m3 = Sse2.LoadVector128(m + Vector128<uint>.Count * 3);

<#
for (int i = 0; i < 10; i++) {
	WriteLine($"\t\t//ROUND {i+1}");
	loadcode(i, 0);
	g1();
	loadcode(i, 1);
	g2();
	diagonalize();

	loadcode(i, 2);
	g1();
	loadcode(i, 3);
	g2();
	undiagonalize();
}
#>
		row1 = Sse2.Xor(row1, row3);
		row2 = Sse2.Xor(row2, row4);
		row1 = Sse2.Xor(row1, Sse2.LoadVector128(sh));
		row2 = Sse2.Xor(row2, Sse2.LoadVector128(sh + Vector128<uint>.Count));
		Sse2.Store(sh, row1);
		Sse2.Store(sh + Vector128<uint>.Count, row2);
	}
}
#endif
<#+

void diagonalize() {
#>
		//DIAGONALIZE
		row1 = Sse2.Shuffle(row1, 0b_10_01_00_11);
		row4 = Sse2.Shuffle(row4, 0b_01_00_11_10);
		row3 = Sse2.Shuffle(row3, 0b_00_11_10_01);

<#+
}

void undiagonalize() {
#>
		//UNDIAGONALIZE
		row1 = Sse2.Shuffle(row1, 0b_00_11_10_01);
		row4 = Sse2.Shuffle(row4, 0b_01_00_11_10);
		row3 = Sse2.Shuffle(row3, 0b_10_01_00_11);

<#+
}

void g1() {
#>

		//G1
		row1 = Sse2.Add(Sse2.Add(row1, b0), row2);
		row4 = Avx512F.VL.RotateRight(Sse2.Xor(row4, row1), 16);

		row3 = Sse2.Add(row3, row4);
		row2 = Avx512F.VL.RotateRight(Sse2.Xor(row2, row3), 12);

<#+
}

void g2() {
#>

		//G2
		row1 = Sse2.Add(Sse2.Add(row1, b0), row2);
		row4 = Avx512F.VL.RotateRight(Sse2.Xor(row4, row1), 8);

		row3 = Sse2.Add(row3, row4);
		row2 = Avx512F.VL.RotateRight(Sse2.Xor(row2, row3), 7);

<#+
}

void loadcode(int round, int part) {
	int r = round % 10 * 10 + part;
	switch (r) {
		case 0:
#>
		<#= round == 0 ? "var " : "" #>b0 = Sse.Shuffle(m0.AsSingle(), m1.AsSingle(), 0b_10_00_10_00).AsUInt32();
<#+
			break;
		case 1:
#>
		b0 = Sse.Shuffle(m0.AsSingle(), m1.AsSingle(), 0b_11_01_11_01).AsUInt32();
<#+
			break;
		case 2:
#>
		<#= round == 0 ? "var " : "" #>t0 = Ssse3.AlignRight(m2, m3, 8);
		<#= round == 0 ? "var " : "" #>t1 = Ssse3.AlignRight(m3, m2, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_10_00_10_00).AsUInt32();
<#+
			break;
		case 3:
#>
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_11_01_11_01).AsUInt32();
<#+
			break;
		case 10:
#>
		t0 = Ssse3.AlignRight(m1, m3, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), b0.AsSingle(), 0b_11_01_10_00).AsUInt32();
<#+
			break;
		case 11:
#>
		t0 = Ssse3.AlignRight(m1, m3, 12);
		b0 = Sse.Shuffle(m2.AsSingle(), t0.AsSingle(), 0b_11_00_00_10).AsUInt32();
<#+
			break;
		case 12:
#>
		t0 = Sse2.UnpackLow(m1, m0);
		t1 = Ssse3.AlignRight(m0, m2, 12);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_00_01_11_10).AsUInt32();
<#+
			break;
		case 13:
#>
		t0 = Ssse3.AlignRight(m3, m0, 12);
		t1 = Sse2.UnpackHigh(m0, m1);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_11_00_01_00).AsUInt32();
<#+
			break;
		case 20:
#>
		t0 = Ssse3.AlignRight(m3, m2, 12);
		t1 = Ssse3.AlignRight(m1, m3, 12);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_00_10_01_00).AsUInt32();
<#+
			break;
		case 21:
#>
		t0 = Sse2.UnpackLow(m2, m0);
		t1 = Ssse3.AlignRight(m3, m0, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_11_00_01_00).AsUInt32();
<#+
			break;
		case 22:
#>
		t0 = Sse2.UnpackHigh(m0, m1);
		b0 = Sse.Shuffle(m2.AsSingle(), t0.AsSingle(), 0b_11_10_10_01).AsUInt32();
<#+
			break;
		case 23:
#>
		t0 = Ssse3.AlignRight(m1, m3, 8);
		t1 = Ssse3.AlignRight(m0, m1, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_11_00_00_10).AsUInt32();
<#+
			break;
		case 30:
#>
		t0 = Sse2.UnpackHigh(m0, m1);
		t1 = Ssse3.AlignRight(m3, m2, 12);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_00_10_10_11).AsUInt32();
<#+
			break;
		case 31:
#>
		t0 = Sse2.UnpackLow(m2, m0);
		b0 = Sse.Shuffle(t0.AsSingle(), m3.AsSingle(), 0b_10_00_11_10).AsUInt32();
<#+
			break;
		case 32:
#>
		t0 = Ssse3.AlignRight(m0, m3, 12);
		b0 = Sse.Shuffle(t0.AsSingle(), m1.AsSingle(), 0b_00_01_11_00).AsUInt32();
<#+
			break;
		case 33:
#>
		t0 = Ssse3.AlignRight(m2, m1, 8);
		t1 = Ssse3.AlignRight(m0, m2, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_10_00_00_10).AsUInt32();
<#+
			break;
		case 40:
#>
		t0 = Sse2.UnpackLow(m2, m1);
		t1 = Sse2.UnpackHigh(m0, m2);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_01_00_11_10).AsUInt32();
<#+
			break;
		case 41:
#>
		t0 = Ssse3.AlignRight(m0, m1, 12);
		t1 = Ssse3.AlignRight(m1, m3, 12);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_00_01_00_01).AsUInt32();
<#+
			break;
		case 42:
#>
		t0 = Sse2.UnpackHigh(m0, m3);
		t1 = Sse2.UnpackHigh(m2, m1);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_01_10_01_10).AsUInt32();
<#+
			break;
		case 43:
#>
		t0 = Sse2.UnpackLow(m0, m3);
		t1 = Sse2.UnpackLow(m3, m2);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_01_00_10_11).AsUInt32();
<#+
			break;
		case 50:
#>
		t0 = Sse2.UnpackHigh(m0, m1);
		t1 = Sse2.UnpackLow(m2, m0);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_00_01_01_00).AsUInt32();
<#+
			break;
		case 51:
#>
		t0 = Ssse3.AlignRight(m3, m2, 8);
		t1 = Sse2.UnpackHigh(m0, m2);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_10_11_00_10).AsUInt32();
<#+
			break;
		case 52:
#>
		t0 = Sse2.UnpackLow(m1, m0);
		t1 = Sse2.UnpackHigh(m1, m3);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_11_10_00_11).AsUInt32();
<#+
			break;
		case 53:
#>
		t0 = Sse2.UnpackLow(m3, m2);
		t1 = Ssse3.AlignRight(m1, m3, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_00_11_10_11).AsUInt32();
<#+
			break;
		case 60:
#>
		t0 = Sse2.UnpackLow(m0, m3);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_10_00_10_01).AsUInt32();
<#+
			break;
		case 61:
#>
		t0 = Ssse3.AlignRight(m3, m2, 8);
		b0 = Sse.Shuffle(t1.AsSingle(), t0.AsSingle(), 0b_00_11_01_11).AsUInt32();
<#+
			break;
		case 62:
#>
		t0 = Sse2.UnpackLow(m2, m0);
		t1 = Ssse3.AlignRight(m2, m1, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_11_00_01_00).AsUInt32();
<#+
			break;
		case 63:
#>
		t0 = Sse2.UnpackHigh(m2, m1);
		b0 = Sse.Shuffle(t0.AsSingle(), m0.AsSingle(), 0b_10_11_11_10).AsUInt32();
<#+
			break;
		case 70:
#>
		t0 = Ssse3.AlignRight(m3, m1, 12);
		t1 = Ssse3.AlignRight(m3, m0, 12);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_00_01_00_10).AsUInt32();
<#+
			break;
		case 71:
#>
		t0 = Sse2.UnpackHigh(m2, m3);
		t1 = Sse2.UnpackLow(m2, m0);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_10_11_01_10).AsUInt32();
<#+
			break;
		case 72:
#>
		t0 = Ssse3.AlignRight(m1, m0, 8);
		t1 = Ssse3.AlignRight(m2, m3, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_10_01_11_00).AsUInt32();
<#+
			break;
		case 73:
#>
		t0 = Ssse3.AlignRight(m0, m2, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), m1.AsSingle(), 0b_10_00_10_00).AsUInt32();
<#+
			break;
		case 80:
#>
		t1 = Sse2.UnpackHigh(m1, m3);
		b0 = Sse.Shuffle(t1.AsSingle(), t0.AsSingle(), 0b_10_01_01_00).AsUInt32();
<#+
			break;
		case 81:
#>
		t0 = Ssse3.AlignRight(m2, m3, 8);
		t1 = Ssse3.AlignRight(m2, m0, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_10_01_11_01).AsUInt32();
<#+
			break;
		case 82:
#>
		t0 = Ssse3.AlignRight(m3, m2, 8);
		t1 = Sse2.UnpackLow(m0, m3);
		b0 = Sse.Shuffle(t0.AsSingle(), t1.AsSingle(), 0b_10_11_10_00).AsUInt32();
<#+
			break;
		case 83:
#>
		t0 = Ssse3.AlignRight(m1, m0, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), m1.AsSingle(), 0b_00_11_00_11).AsUInt32();
<#+
			break;
		case 90:
#>
		t1 = Ssse3.AlignRight(m0, m1, 12);
		b0 = Sse.Shuffle(m2.AsSingle(), t1.AsSingle(), 0b_10_00_00_10).AsUInt32();
<#+
			break;
		case 91:
#>
		b0 = Sse.Shuffle(t0.AsSingle(), m1.AsSingle(), 0b_01_10_10_00).AsUInt32();
<#+
			break;
		case 92:
#>
		t0 = Ssse3.AlignRight(m2, m0, 8);
		b0 = Sse.Shuffle(m3.AsSingle(), t0.AsSingle(), 0b_01_11_11_01).AsUInt32();
<#+
			break;
		case 93:
#>
		t0 = Ssse3.AlignRight(m0, m2, 8);
		b0 = Sse.Shuffle(t0.AsSingle(), m3.AsSingle(), 0b_00_10_01_10).AsUInt32();
<#+
			break;
	}
}
#>